/*
 * (c) Copyright [2017] EntIT Software LLC
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
package com.fortify.plugin.api;

/**
 * StaticVulnerabilityBuilder extension for static issues.
 * Static vulnerabilities are the ones that are found by static code analysers (like SCA) performed without actually
 * executing programs.
 * <p>
 * All of this attributes are optional. See {@link BasicVulnerabilityBuilder} for generic attributes.
 */
public interface StaticVulnerabilityBuilder extends BasicVulnerabilityBuilder<StaticVulnerabilityBuilder> {

    /**
     * Set name of package where the vulnerability has been found.
     *
     * <b>Value of this attribute is optional</b> if programming language used to develop vulnerable application does not
     * support package notation of if vulnerability scanner does not provide this information for this specific vulnerability
     * (e.g. vulnerability is found in application configuration, web.xml, etc).
     * @param packageName a package name
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setPackageName(String packageName);

    /**
     * Set name of class where the vulnerability has been found.
     *
     * <b>Value of this attribute is optional</b> if programming language used to develop vulnerable application does not
     * support class notation of if vulnerability scanner does not provide this information for this specific vulnerability
     * (e.g. vulnerability is found in application configuration, web.xml, etc).
     * @param className a class name.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setClassName(String className);

    /**
     * Set full name of the file where vulnerable code is actually located.
     * If vulnerability scanner provides source files for every single vulnerability it founds, fileName attribute is
     * used for source files identification. Otherwise it is a descriptive attribute of the vulnerability.
     *
     * <b>Value of this attribute is optional</b> but it is highly recommended to set this attribute if analyser provides names
     * of vulnerable files.
     * @param fileName full name of the file (e.g. /project-dir/module-dir/Builder.java, c:\project-dir\module-dir\WindowsHandler.cpp, etc)
     * where vulnerability is found.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setFileName(String fileName);

    /**
     * Set name of function located in the vulnerability file {@link com.fortify.plugin.api.StaticVulnerabilityBuilder#setFileName} where the vulnerability has been found.
     *
     * <b>Value of this attribute is optional</b> if programming language used to develop vulnerable application does not
     * support function notation of if vulnerability scanner does not provide this information for this specific vulnerability
     * (e.g. vulnerability is found in application configuration, web.xml, etc).
     * @param functionName a function name
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setFunctionName(String functionName);

    /**
     * Set line number in the vulnerable file {@link com.fortify.plugin.api.StaticVulnerabilityBuilder#setFileName} where the
     * vulnerability has been found.
     *
     * <b>Value of this attribute is optional</b> but it is highly recommended to set value of this attribute if
     * vulnerability scanner provides line numbers.
     * @param lineNumber a line number
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setLineNumber(Integer lineNumber);

    /**
     * Set name of the a program point tainted data enters a program through.
     * Common examples include:
     * <ul>
     *  <li>A function that reads data from network sources such as an HTTP request
     *  <li>A function that reads data from an untrusted data sources (a database written to by other programs)
     * </ul>
     * In most cases it is a function call that executes vulnerable code directly or through pass through execution points.
     *
     * <b>Value of this attribute is optional</b> and can be set to null if analyzer that found an issue is not a data flow
     * analyzer or if analyzer does not provide this information. For data flow attributes it is recommended to set value
     * of this attribute since it makes vulnerability analysis in SSC easier.
     * @param source string that identifies vulnerability source.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setSource(String source);

    /**
     * Set name of the context that contains vulnerability sources. In most cases it can be a full function name that
     * executes vulnerability source code.
     *
     * <b>Value of this attribute is optional</b> and can be set to null if analyzer that found an issue is not a data flow
     * analyzer or if analyzer does not provide this information. For data flow attributes it is recommended to set value
     * of this attribute since it makes vulnerability analysis in SSC easier.
     * @param sourceContext string that identifies vulnerability source context.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setSourceContext(String sourceContext);

    /**
     * Set file name where vulnerability source {@link #setSource(String)} is located.
     *
     * Meaning of this attribute differs from {@link #setFileName(String)} attribute.
     * File name attribute points to the file where vulnerable code is actually located.
     * Source file points to the file where vulnerability source is located.
     *
     * For example, some project consists of 2 files: Controller.java and Service.java.
     * Class defined in Controller.java uses vulnerable doService function defined in Service.java file.
     * In this case vulnerability file name must be set to the path to Service.java file.
     * As for sourceFile attribute, it must be equal to the path to Controller.java file since it contains code that uses
     * vulnerable doService function.
     *
     * <b>Value of this attribute is optional</b> and can be set to null if analyzer that found an issue is not a data flow
     * analyzer or if analyzer does not provide this information. For data flow attributes it is recommended to set value
     * of this attribute since it makes vulnerability analysis in SSC easier.
     * @param sourceFile full name of the vulnerability source file.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setSourceFile(String sourceFile);

    /**
     * Set line number in the source file {@link #setSourceFile(String)} where vulnerability source {@link #setSource(String)} is located.
     *
     * <b>Value of this attribute is optional</b> and can be set to null if analyzer that found an issue is not a data flow
     * analyzer or if analyzer does not provide this information. For data flow attributes it is recommended to set value
     * of this attribute since it makes vulnerability analysis in SSC easier.
     * @param sourceLine line number inside sourceFile where vulnerability source is located.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setSourceLine(Integer sourceLine);

    /**
     * Set taint sink name (it is usually a function name of just one line code fragment) which is program point to which
     * tainted data must not flow. When the Dataflow Analyzer detects a path through which tainted data can flow from
     * source to sink, it reports an issue. A taint sink rule can contain a conditional expression which limits paths
     * reported to a taint sink by examining taint flags.
     * Common examples include:
     * <ul>
     *  <li>A function that takes a SQL string and executes a query against a database connection
     *  <li>A function that takes a string and executes the command described by the string
     * </ul>
     *
     * <b>Value of this attribute is optional</b> and can be set to null if analyzer that found an issue is not a data flow
     * analyzer or if analyzer does not provide this information. For data flow attributes it is recommended to set value
     * of this attribute since it makes vulnerability analysis in SSC easier.
     * @param sink string that identifies vulnerability sink.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setSink(String sink);

    /**
     * Set name of the context that contains vulnerability sink. In most cases it can be a full function name that
     * executes vulnerability sink code.
     *
     * <b>Value of this attribute is optional</b> and can be set to null if analyzer that found an issue is not a data flow
     * analyzer or if analyzer does not provide this information. For data flow attributes it is recommended to set value
     * of this attribute since it makes vulnerability analysis in SSC easier.
     * @param sinkContext string that identifies vulnerability sink context.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setSinkContext(String sinkContext);

    /**
     * Set confidence level which estimates that vulnerability found in virtual (overridden) function will be executed
     * by tainted source {@link com.fortify.plugin.api.StaticVulnerabilityBuilder#setSource(String)}.
     *
     * For example, vulnerability source {@link com.fortify.plugin.api.StaticVulnerabilityBuilder#setSource(String)}
     * is located in Controller class. In addition, there is Service interface that has 2 implementations: Service1 (not
     * vulnerable) and Service2 (vulnerable). Exact implementation of Service interface is injected in Controller and
     * controller will execute vulnerable code if Service2 implementation is injected.
     *
     * Value of this attribute defines the probability that vulnerable implementation of interface / abstract class
     * will be executed.
     *
     * <b>Value of this attribute is optional.</b> This is SCA specific metrics. It is recommended for 3rd party parsers
     * to set value of this attribute to an average value 0.5.
     * @param minVirtualCallConfidence minimum confidence level (from 0.0 to 1.0)
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setMinVirtualCallConfidence(Float minVirtualCallConfidence);

    /**
     * Set level of complexity (from 0 to 12) to fix this vulnerability.
     *
     * <b>Value of this attribute is optional.</b> This is SCA specific metrics. It is recommended for 3rd party parsers
     * to set value of this attribute to 0.
     * @param remediationConstant value of remediationConstant.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setRemediationConstant(Float remediationConstant);

    /**
     * <p>
     * A taint flag is an attribute of tainted data that enables the Dataflow Analyzer to discriminate between different
     * types of taint. This is important because it enables the Dataflow Analyzer to accurately identify issues.
     * </p>
     * <p>
     * For example, the input from both HTTP parameters and local configuration files of a web application might be
     * tainted. The attack vectors in each instance are substantially different. An	attacker can easily manipulate HTTP
     * parameters. Manipulating	configuration files on the system is much more difficult.
     * </p>
     * <p>
     * Consider a function which checks input for SQL meta characters. Once tainted data has passed through this
     * function, it should be safe to use in a taint sink for SQL injection. However, the data cannot be considered
     * untainted. It is still dangerous to use in other contexts, such as a taint sink for command injection. The use of
     * taint flags in rules enables the Dataflow Analyzer to determine whether the tainted data is safe in a specific context.
     * </p>
     * <b>Value of this attribute is mandatory for issues produced by data flow analyzers</b> and can be set to null for
     * any other types of analysers. This is SCA specific metrics. It is recommended for 3rd party parsers to set value
     * of this attribute to null.
     * @param taintFlag comma separated string that contains one or more taint flags.
     * @return reference to this builder instance.
     */
    StaticVulnerabilityBuilder setTaintFlag(String taintFlag);
}
